diff -urp linuxmint-muffin-0e57527/configure.in rat4-muffin-80db11c/configure.in
--- a/configure.in	2012-03-10 15:13:14.000000000 +0000
+++ b/configure.in	2012-03-12 02:40:04.000000000 +0000
@@ -61,7 +61,7 @@ AC_CHECK_SIZEOF(__int64)
 ## byte order
 AC_C_BIGENDIAN
 
-GTK_MIN_VERSION=2.91.7
+GTK_MIN_VERSION=3.3.3
 CANBERRA_GTK=libcanberra-gtk3
 CANBERRA_GTK_VERSION=0.26
 
diff -urp linuxmint-muffin-0e57527/src/compositor/meta-background-actor.c rat4-muffin-80db11c/src/compositor/meta-background-actor.c
--- a/src/compositor/meta-background-actor.c	2012-03-10 15:13:14.000000000 +0000
+++ b/src/compositor/meta-background-actor.c	2012-03-12 02:40:04.000000000 +0000
@@ -28,6 +28,9 @@
 #define COGL_ENABLE_EXPERIMENTAL_API
 #include <cogl/cogl-texture-pixmap-x11.h>
 
+#define CLUTTER_ENABLE_EXPERIMENTAL_API
+#include <clutter/clutter.h>
+
 #include <X11/Xatom.h>
 
 #include "cogl-utils.h"
@@ -537,9 +540,11 @@ meta_background_actor_update (MetaScreen
   if (root_pixmap_id != None)
     {
       CoglHandle texture;
+      CoglContext *ctx = clutter_backend_get_cogl_context (clutter_get_default_backend ());
+      GError *error = NULL;
 
       meta_error_trap_push (display);
-      texture = cogl_texture_pixmap_x11_new (root_pixmap_id, FALSE);
+      texture = cogl_texture_pixmap_x11_new (ctx, root_pixmap_id, FALSE, &error);
       meta_error_trap_pop (display);
 
       if (texture != COGL_INVALID_HANDLE)
@@ -550,6 +555,12 @@ meta_background_actor_update (MetaScreen
           background->have_pixmap = True;
           return;
         }
+      else
+        {
+          g_warning ("Failed to create background texture from pixmap: %s",
+                     error->message);
+          g_error_free (error);
+        }
     }
 
   background->have_pixmap = False;
diff -urp linuxmint-muffin-0e57527/src/compositor/meta-shaped-texture.c rat4-muffin-80db11c/src/compositor/meta-shaped-texture.c
--- a/src/compositor/meta-shaped-texture.c	2012-03-10 15:13:14.000000000 +0000
+++ b/src/compositor/meta-shaped-texture.c	2012-03-12 02:40:04.000000000 +0000
@@ -25,32 +25,38 @@
 
 #include <config.h>
 
-#include "meta-shaped-texture.h"
+#define CLUTTER_ENABLE_EXPERIMENTAL_API
+#define COGL_ENABLE_EXPERIMENTAL_API
+
+#include <meta/meta-shaped-texture.h>
 #include "meta-texture-tower.h"
 #include "meta-texture-rectangle.h"
 
 #include <clutter/clutter.h>
 #include <cogl/cogl.h>
+#include <cogl/cogl-texture-pixmap-x11.h>
 #include <string.h>
 
 static void meta_shaped_texture_dispose  (GObject    *object);
-static void meta_shaped_texture_notify   (GObject    *object,
-					  GParamSpec *pspec);
 
 static void meta_shaped_texture_paint (ClutterActor       *actor);
 static void meta_shaped_texture_pick  (ClutterActor       *actor,
 				       const ClutterColor *color);
 
-static void meta_shaped_texture_update_area (ClutterX11TexturePixmap *texture,
-					     int                      x,
-					     int                      y,
-					     int                      width,
-					     int                      height);
+static void meta_shaped_texture_get_preferred_width (ClutterActor *self,
+                                                     gfloat        for_height,
+                                                     gfloat       *min_width_p,
+                                                     gfloat       *natural_width_p);
+
+static void meta_shaped_texture_get_preferred_height (ClutterActor *self,
+                                                      gfloat        for_width,
+                                                      gfloat       *min_height_p,
+                                                      gfloat       *natural_height_p);
 
 static void meta_shaped_texture_dirty_mask (MetaShapedTexture *stex);
 
 G_DEFINE_TYPE (MetaShapedTexture, meta_shaped_texture,
-               CLUTTER_X11_TYPE_TEXTURE_PIXMAP);
+               CLUTTER_TYPE_ACTOR);
 
 #define META_SHAPED_TEXTURE_GET_PRIVATE(obj) \
   (G_TYPE_INSTANCE_GET_PRIVATE ((obj), META_TYPE_SHAPED_TEXTURE, \
@@ -59,6 +65,8 @@ G_DEFINE_TYPE (MetaShapedTexture, meta_s
 struct _MetaShapedTexturePrivate
 {
   MetaTextureTower *paint_tower;
+  Pixmap pixmap;
+  CoglHandle texture;
   CoglHandle mask_texture;
   CoglHandle material;
   CoglHandle material_unshaped;
@@ -71,6 +79,7 @@ struct _MetaShapedTexturePrivate
 
   cairo_region_t *visible_pixels_region;
 
+  guint tex_width, tex_height;
   guint mask_width, mask_height;
 
   guint create_mipmaps : 1;
@@ -81,16 +90,14 @@ meta_shaped_texture_class_init (MetaShap
 {
   GObjectClass *gobject_class = (GObjectClass *) klass;
   ClutterActorClass *actor_class = (ClutterActorClass *) klass;
-  ClutterX11TexturePixmapClass *x11_texture_class = (ClutterX11TexturePixmapClass *) klass;
 
   gobject_class->dispose = meta_shaped_texture_dispose;
-  gobject_class->notify = meta_shaped_texture_notify;
 
+  actor_class->get_preferred_width = meta_shaped_texture_get_preferred_width;
+  actor_class->get_preferred_height = meta_shaped_texture_get_preferred_height;
   actor_class->paint = meta_shaped_texture_paint;
   actor_class->pick = meta_shaped_texture_pick;
 
-  x11_texture_class->update_area = meta_shaped_texture_update_area;
-
   g_type_class_add_private (klass, sizeof (MetaShapedTexturePrivate));
 }
 
@@ -106,6 +113,7 @@ meta_shaped_texture_init (MetaShapedText
   priv->overlay_region = NULL;
   priv->visible_pixels_region = NULL;
   priv->paint_tower = meta_texture_tower_new ();
+  priv->texture = COGL_INVALID_HANDLE;
   priv->mask_texture = COGL_INVALID_HANDLE;
   priv->create_mipmaps = TRUE;
 }
@@ -132,6 +140,11 @@ meta_shaped_texture_dispose (GObject *ob
       cogl_handle_unref (priv->material_unshaped);
       priv->material_unshaped = COGL_INVALID_HANDLE;
     }
+  if (priv->texture != COGL_INVALID_HANDLE)
+    {
+      cogl_handle_unref (priv->texture);
+      priv->texture = COGL_INVALID_HANDLE;
+    }
 
   meta_shaped_texture_set_shape_region (self, NULL);
   meta_shaped_texture_set_clip_region (self, NULL);
@@ -141,31 +154,6 @@ meta_shaped_texture_dispose (GObject *ob
 }
 
 static void
-meta_shaped_texture_notify (GObject    *object,
-			    GParamSpec *pspec)
-{
-  if (G_OBJECT_CLASS (meta_shaped_texture_parent_class)->notify)
-    G_OBJECT_CLASS (meta_shaped_texture_parent_class)->notify (object, pspec);
-
-  /* It seems like we could just do this out of update_area(), but unfortunately,
-   * clutter_glx_texture_pixmap() doesn't call through the vtable on the
-   * initial update_area, so we need to look for changes to the texture
-   * explicitly.
-   */
-  if (strcmp (pspec->name, "cogl-texture") == 0)
-    {
-      MetaShapedTexture *stex = (MetaShapedTexture *) object;
-      MetaShapedTexturePrivate *priv = stex->priv;
-
-      meta_shaped_texture_clear (stex);
-
-      if (priv->create_mipmaps)
-	meta_texture_tower_set_base_texture (priv->paint_tower,
-					       clutter_texture_get_cogl_texture (CLUTTER_TEXTURE (stex)));
-    }
-}
-
-static void
 meta_shaped_texture_dirty_mask (MetaShapedTexture *stex)
 {
   MetaShapedTexturePrivate *priv = stex->priv;
@@ -310,7 +298,7 @@ meta_shaped_texture_ensure_mask (MetaSha
   CoglHandle paint_tex;
   guint tex_width, tex_height;
 
-  paint_tex = clutter_texture_get_cogl_texture (CLUTTER_TEXTURE (stex));
+  paint_tex = priv->texture;
 
   if (paint_tex == COGL_INVALID_HANDLE)
     return;
@@ -451,13 +439,13 @@ meta_shaped_texture_paint (ClutterActor
   if (priv->create_mipmaps)
     paint_tex = meta_texture_tower_get_paint_texture (priv->paint_tower);
   else
-    paint_tex = clutter_texture_get_cogl_texture (CLUTTER_TEXTURE (stex));
+    paint_tex = priv->texture;
 
   if (paint_tex == COGL_INVALID_HANDLE)
     return;
 
-  tex_width = cogl_texture_get_width (paint_tex);
-  tex_height = cogl_texture_get_height (paint_tex);
+  tex_width = priv->tex_width;
+  tex_height = priv->tex_height;
 
   if (tex_width == 0 || tex_height == 0) /* no contents yet */
     return;
@@ -574,7 +562,7 @@ meta_shaped_texture_pick (ClutterActor
       ClutterActorBox alloc;
       guint tex_width, tex_height;
 
-      paint_tex = clutter_texture_get_cogl_texture (CLUTTER_TEXTURE (stex));
+      paint_tex = priv->texture;
 
       if (paint_tex == COGL_INVALID_HANDLE)
         return;
@@ -602,19 +590,41 @@ meta_shaped_texture_pick (ClutterActor
 }
 
 static void
-meta_shaped_texture_update_area (ClutterX11TexturePixmap *texture,
-				 int                      x,
-				 int                      y,
-				 int                      width,
-				 int                      height)
+meta_shaped_texture_get_preferred_width (ClutterActor *self,
+                                         gfloat        for_height,
+                                         gfloat       *min_width_p,
+                                         gfloat       *natural_width_p)
 {
-  MetaShapedTexture *stex = (MetaShapedTexture *) texture;
-  MetaShapedTexturePrivate *priv = stex->priv;
+  MetaShapedTexturePrivate *priv;
 
-  CLUTTER_X11_TEXTURE_PIXMAP_CLASS (meta_shaped_texture_parent_class)->update_area (texture,
-                                                                                      x, y, width, height);
+  g_return_if_fail (META_IS_SHAPED_TEXTURE (self));
 
-  meta_texture_tower_update_area (priv->paint_tower, x, y, width, height);
+  priv = META_SHAPED_TEXTURE (self)->priv;
+
+  if (min_width_p)
+    *min_width_p = 0;
+
+  if (natural_width_p)
+    *natural_width_p = priv->tex_width;
+}
+
+static void
+meta_shaped_texture_get_preferred_height (ClutterActor *self,
+                                          gfloat        for_width,
+                                          gfloat       *min_height_p,
+                                          gfloat       *natural_height_p)
+{
+  MetaShapedTexturePrivate *priv;
+
+  g_return_if_fail (META_IS_SHAPED_TEXTURE (self));
+
+  priv = META_SHAPED_TEXTURE (self)->priv;
+
+  if (min_height_p)
+    *min_height_p = 0;
+
+  if (natural_height_p)
+    *natural_height_p = priv->tex_height;
 }
 
 ClutterActor *
@@ -640,34 +650,16 @@ meta_shaped_texture_set_create_mipmaps (
   if (create_mipmaps != priv->create_mipmaps)
     {
       CoglHandle base_texture;
-
       priv->create_mipmaps = create_mipmaps;
-
       base_texture = create_mipmaps ?
-	clutter_texture_get_cogl_texture (CLUTTER_TEXTURE (stex)) : COGL_INVALID_HANDLE;
-
+        priv->texture : COGL_INVALID_HANDLE;
       meta_texture_tower_set_base_texture (priv->paint_tower, base_texture);
     }
 }
 
-/* This is a workaround for deficiencies in the hack tower:
- *
- * When we call clutter_x11_texture_pixmap_set_pixmap(tp, None),
- * ClutterX11TexturePixmap knows that it has to get rid of the old texture, but
- * clutter_texture_set_cogl_texture(texture, COGL_INVALID_HANDLE) isn't allowed, so
- * it grabs the material for the texture and manually sets the texture in it. This means
- * that the "cogl-texture" property isn't notified, so we don't find out about it.
- *
- * And if we keep the CoglX11TexturePixmap around after the X pixmap is freed, then
- * we'll trigger X errors when we actually try to free it.
- *
- * The only correct thing to do here is to change our code to derive
- * from ClutterActor and get rid of the inheritance hack tower.  Once
- * we want to depend on Clutter-1.4 (which has CoglTexturePixmapX11),
- * that will be very easy to do.
- */
 void
-meta_shaped_texture_clear (MetaShapedTexture *stex)
+meta_shaped_texture_set_shape_region (MetaShapedTexture *stex,
+                                      cairo_region_t    *region)
 {
   MetaShapedTexturePrivate *priv;
 
@@ -675,38 +667,88 @@ meta_shaped_texture_clear (MetaShapedTex
 
   priv = stex->priv;
 
-  meta_texture_tower_set_base_texture (priv->paint_tower, COGL_INVALID_HANDLE);
+  if (priv->shape_region != NULL)
+    {
+      cairo_region_destroy (priv->shape_region);
+      priv->shape_region = NULL;
+    }
 
-  if (priv->material != COGL_INVALID_HANDLE)
-    cogl_material_set_layer (priv->material, 0, COGL_INVALID_HANDLE);
+  if (region != NULL)
+    {
+      cairo_region_reference (region);
+      priv->shape_region = region;
+    }
 
-  if (priv->material_unshaped != COGL_INVALID_HANDLE)
-    cogl_material_set_layer (priv->material_unshaped, 0, COGL_INVALID_HANDLE);
+  meta_shaped_texture_dirty_mask (stex);
+  clutter_actor_queue_redraw (CLUTTER_ACTOR (stex));
 }
 
 void
-meta_shaped_texture_set_shape_region (MetaShapedTexture *stex,
-                                      cairo_region_t    *region)
+meta_shaped_texture_update_area (MetaShapedTexture *stex,
+				 int                x,
+				 int                y,
+				 int                width,
+				 int                height)
 {
   MetaShapedTexturePrivate *priv;
+  const cairo_rectangle_int_t clip = { x, y, width, height };
+
+  priv = stex->priv;
+
+  if (priv->texture == COGL_INVALID_HANDLE)
+    return;
+
+  cogl_texture_pixmap_x11_update_area (priv->texture, x, y, width, height);
+
+  meta_texture_tower_update_area (priv->paint_tower, x, y, width, height);
+
+  clutter_actor_queue_redraw_with_clip (CLUTTER_ACTOR (stex), &clip);
+}
+
+static void
+set_cogl_texture (MetaShapedTexture *stex,
+                  CoglHandle         cogl_tex)
+{
+  MetaShapedTexturePrivate *priv;
+  guint width, height;
 
   g_return_if_fail (META_IS_SHAPED_TEXTURE (stex));
 
   priv = stex->priv;
 
-  if (priv->shape_region != NULL)
+  if (priv->texture != COGL_INVALID_HANDLE)
+    cogl_handle_unref (priv->texture);
+
+  priv->texture = cogl_tex;
+
+  if (priv->material != COGL_INVALID_HANDLE)
+    cogl_material_set_layer (priv->material, 0, cogl_tex);
+
+  if (priv->material_unshaped != COGL_INVALID_HANDLE)
+    cogl_material_set_layer (priv->material_unshaped, 0, cogl_tex);
+
+  if (cogl_tex != COGL_INVALID_HANDLE)
     {
-      cairo_region_destroy (priv->shape_region);
-      priv->shape_region = NULL;
-    }
+      width = cogl_texture_get_width (cogl_tex);
+      height = cogl_texture_get_height (cogl_tex);
 
-  if (region != NULL)
+      if (width != priv->tex_width ||
+          height != priv->tex_height)
+        {
+          priv->tex_width = width;
+          priv->tex_height = height;
+
+          clutter_actor_queue_relayout (CLUTTER_ACTOR (stex));
+        }
+    }
+  else
     {
-      cairo_region_reference (region);
-      priv->shape_region = region;
+      /* size changed to 0 going to an invalid handle */
+      priv->tex_width = 0;
+      priv->tex_height = 0;
+      clutter_actor_queue_relayout (CLUTTER_ACTOR (stex));
     }
 
-  meta_shaped_texture_dirty_mask (stex);
   clutter_actor_queue_redraw (CLUTTER_ACTOR (stex));
 }
 
@@ -729,12 +771,58 @@ meta_shaped_texture_get_visible_pixels_r
 }
 
 /**
+ * meta_shaped_texture_set_pixmap:
+ * @stex: The #MetaShapedTexture
+ * @pixmap: The pixmap you want the stex to assume
+ */
+void
+meta_shaped_texture_set_pixmap (MetaShapedTexture *stex,
+                                Pixmap             pixmap)
+{
+  MetaShapedTexturePrivate *priv;
+
+  g_return_if_fail (META_IS_SHAPED_TEXTURE (stex));
+
+  priv = stex->priv;
+
+  if (priv->pixmap == pixmap)
+    return;
+
+  priv->pixmap = pixmap;
+
+  if (pixmap != None)
+    {
+      CoglContext *ctx =
+        clutter_backend_get_cogl_context (clutter_get_default_backend ());
+      set_cogl_texture (stex, cogl_texture_pixmap_x11_new (ctx, pixmap, FALSE, NULL));
+    }
+  else
+    set_cogl_texture (stex, COGL_INVALID_HANDLE);
+
+  if (priv->create_mipmaps)
+    meta_texture_tower_set_base_texture (priv->paint_tower, priv->texture);
+}
+
+/**
+ * meta_shaped_texture_get_texture:
+ * @stex: The #MetaShapedTexture
+ *
+ * Returns: (transfer none): the unshaped texture
+ */
+CoglHandle
+meta_shaped_texture_get_texture (MetaShapedTexture *stex)
+{
+  g_return_val_if_fail (META_IS_SHAPED_TEXTURE (stex), COGL_INVALID_HANDLE);
+  return stex->priv->texture;
+}
+
+/**
  * meta_shaped_texture_set_overlay_path:
  * @stex: a #MetaShapedTexture
  * @overlay_region: A region containing the parts of the mask to overlay.
  *   All rectangles in this region are wiped clear to full transparency,
  *   and the overlay path is clipped to this region.
- * @overlay_path (transfer full): This path will be painted onto the mask
+ * @overlay_path: (transfer full): This path will be painted onto the mask
  *   texture with a fully opaque source. Due to the lack of refcounting
  *   in #cairo_path_t, ownership of the path is assumed.
  */
@@ -772,7 +860,7 @@ meta_shaped_texture_set_overlay_path (Me
 
 /**
  * meta_shaped_texture_set_clip_region:
- * @frame: a #MetaShapedTexture
+ * @stex: a #MetaShapedTexture
  * @clip_region: (transfer full): the region of the texture that
  *   is visible and should be painted. OWNERSHIP IS ASSUMED BY
  *   THE FUNCTION (for efficiency to avoid a copy.)
diff -up inuxmint-muffin-0e57527/src/compositor/meta-shaped-texture.h /dev/null
--- a/src/compositor/meta-shaped-texture.h	2012-03-10 15:13:14.000000000 +0000
+++ /dev/null	2012-03-12 09:07:57.316000049 +0000
@@ -1,83 +0,0 @@
-/*
- * shaped texture
- *
- * An actor to draw a texture clipped to a list of rectangles
- *
- * Authored By Neil Roberts  <neil@linux.intel.com>
- *
- * Copyright (C) 2008 Intel Corporation
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- */
-
-#ifndef __META_SHAPED_TEXTURE_H__
-#define __META_SHAPED_TEXTURE_H__
-
-#include <config.h>
-
-#include <clutter/clutter.h>
-#include <clutter/x11/clutter-x11.h>
-
-G_BEGIN_DECLS
-
-#define META_TYPE_SHAPED_TEXTURE            (meta_shaped_texture_get_type())
-#define META_SHAPED_TEXTURE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj),META_TYPE_SHAPED_TEXTURE, MetaShapedTexture))
-#define META_SHAPED_TEXTURE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), META_TYPE_SHAPED_TEXTURE, MetaShapedTextureClass))
-#define META_IS_SHAPED_TEXTURE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), META_TYPE_SHAPED_TEXTURE))
-#define META_IS_SHAPED_TEXTURE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), META_TYPE_SHAPED_TEXTURE))
-#define META_SHAPED_TEXTURE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), META_TYPE_SHAPED_TEXTURE, MetaShapedTextureClass))
-
-typedef struct _MetaShapedTexture        MetaShapedTexture;
-typedef struct _MetaShapedTextureClass   MetaShapedTextureClass;
-typedef struct _MetaShapedTexturePrivate MetaShapedTexturePrivate;
-
-struct _MetaShapedTextureClass
-{
-  ClutterX11TexturePixmapClass parent_class;
-};
-
-struct _MetaShapedTexture
-{
-  ClutterX11TexturePixmap parent;
-
-  MetaShapedTexturePrivate *priv;
-};
-
-GType meta_shaped_texture_get_type (void) G_GNUC_CONST;
-
-ClutterActor *meta_shaped_texture_new (void);
-
-void meta_shaped_texture_set_create_mipmaps (MetaShapedTexture *stex,
-					     gboolean           create_mipmaps);
-
-void meta_shaped_texture_clear (MetaShapedTexture *stex);
-
-void meta_shaped_texture_set_shape_region (MetaShapedTexture *stex,
-                                           cairo_region_t    *region);
-
-cairo_region_t *meta_shaped_texture_get_visible_pixels_region (MetaShapedTexture *stex);
-
-void meta_shaped_texture_set_overlay_path (MetaShapedTexture *stex,
-                                           cairo_region_t    *overlay_region,
-                                           cairo_path_t      *overlay_path);
-
-/* Assumes ownership of clip_region */
-void meta_shaped_texture_set_clip_region (MetaShapedTexture *stex,
-					  cairo_region_t    *clip_region);
-
-G_END_DECLS
-
-#endif /* __META_SHAPED_TEXTURE_H__ */
diff -urp linuxmint-muffin-0e57527/src/compositor/meta-texture-tower.c rat4-muffin-80db11c/src/compositor/meta-texture-tower.c
--- a/src/compositor/meta-texture-tower.c	2012-03-10 15:13:14.000000000 +0000
+++ b/src/compositor/meta-texture-tower.c	2012-03-12 02:40:04.000000000 +0000
@@ -198,6 +198,9 @@ meta_texture_tower_update_area (MetaText
 
   g_return_if_fail (tower != NULL);
 
+  if (tower->textures[0] == COGL_INVALID_HANDLE)
+    return;
+
   texture_width = cogl_texture_get_width (tower->textures[0]);
   texture_height = cogl_texture_get_height (tower->textures[0]);
 
diff -urp linuxmint-muffin-0e57527/src/compositor/meta-window-actor.c rat4-muffin-80db11c/src/compositor/meta-window-actor.c
--- a/src/compositor/meta-window-actor.c	2012-03-10 15:13:14.000000000 +0000
+++ b/src/compositor/meta-window-actor.c	2012-03-12 02:40:04.000000000 +0000
@@ -18,11 +18,11 @@
 #include <meta/errors.h>
 #include "frame.h"
 #include <meta/window.h>
+#include <meta/meta-shaped-texture.h>
 #include "xprops.h"
 
 #include "compositor-private.h"
 #include "meta-shadow-factory-private.h"
-#include "meta-shaped-texture.h"
 #include "meta-window-actor-private.h"
 
 enum {
@@ -946,23 +946,20 @@ static void
 meta_window_actor_damage_all (MetaWindowActor *self)
 {
   MetaWindowActorPrivate *priv = self->priv;
-  ClutterX11TexturePixmap *texture_x11 = CLUTTER_X11_TEXTURE_PIXMAP (priv->actor);
-  guint pixmap_width = 0;
-  guint pixmap_height = 0;
+  CoglHandle texture;
 
   if (!priv->needs_damage_all)
     return;
 
-  g_object_get (texture_x11,
-                "pixmap-width", &pixmap_width,
-                "pixmap-height", &pixmap_height,
-                NULL);
-
-  clutter_x11_texture_pixmap_update_area (texture_x11,
-                                          0,
-                                          0,
-                                          pixmap_width,
-                                          pixmap_height);
+  texture = meta_shaped_texture_get_texture (META_SHAPED_TEXTURE (priv->actor));
+
+  if (!priv->mapped || priv->needs_pixmap)
+    return;
+
+  meta_shaped_texture_update_area (META_SHAPED_TEXTURE (priv->actor),
+                                   0, 0,
+                                   cogl_texture_get_width (texture),
+                                   cogl_texture_get_height (texture));
 
   priv->needs_damage_all = FALSE;
 }
@@ -1201,9 +1198,8 @@ meta_window_actor_detach (MetaWindowActo
    * you are supposed to be able to free a GLXPixmap after freeing the underlying
    * pixmap, but it certainly doesn't work with current DRI/Mesa
    */
-  clutter_x11_texture_pixmap_set_pixmap (CLUTTER_X11_TEXTURE_PIXMAP (priv->actor),
-                                         None);
-  meta_shaped_texture_clear (META_SHAPED_TEXTURE (priv->actor));
+  meta_shaped_texture_set_pixmap (META_SHAPED_TEXTURE (priv->actor),
+                                  None);
   cogl_flush();
 
   XFreePixmap (xdisplay, priv->back_pixmap);
@@ -1827,19 +1823,6 @@ meta_window_actor_reset_visible_regions
   meta_window_actor_clear_shadow_clip (self);
 }
 
-static gboolean
-texture_pixmap_using_extension (ClutterX11TexturePixmap *texture)
-{
-  ClutterTexture *self = CLUTTER_TEXTURE (texture);
-  CoglHandle handle;
-
-  handle = clutter_texture_get_cogl_texture (self);
-
-  return handle != NULL &&
-         cogl_is_texture_pixmap_x11 (handle) &&
-         cogl_texture_pixmap_x11_is_using_tfp_extension (handle);
-}
-
 static void
 check_needs_pixmap (MetaWindowActor *self)
 {
@@ -1873,7 +1856,7 @@ check_needs_pixmap (MetaWindowActor *sel
 
   if (priv->back_pixmap == None)
     {
-      gint pxm_width, pxm_height;
+      CoglHandle texture;
 
       meta_error_trap_push (display);
 
@@ -1902,23 +1885,22 @@ check_needs_pixmap (MetaWindowActor *sel
         meta_shaped_texture_set_create_mipmaps (META_SHAPED_TEXTURE (priv->actor),
                                                 FALSE);
 
-      clutter_x11_texture_pixmap_set_pixmap
-                       (CLUTTER_X11_TEXTURE_PIXMAP (priv->actor),
-                        priv->back_pixmap);
+      meta_shaped_texture_set_pixmap (META_SHAPED_TEXTURE (priv->actor),
+                                      priv->back_pixmap);
+
+      texture = meta_shaped_texture_get_texture (META_SHAPED_TEXTURE (priv->actor));
+
       /*
        * This only works *after* actually setting the pixmap, so we have to
        * do it here.
        * See: http://bugzilla.clutter-project.org/show_bug.cgi?id=2236
        */
-      if (G_UNLIKELY (!texture_pixmap_using_extension (CLUTTER_X11_TEXTURE_PIXMAP (priv->actor))))
+      if (G_UNLIKELY (!cogl_texture_pixmap_x11_is_using_tfp_extension (texture)))
         g_warning ("NOTE: Not using GLX TFP!\n");
 
-      g_object_get (priv->actor,
-                    "pixmap-width", &pxm_width,
-                    "pixmap-height", &pxm_height,
-                    NULL);
-
-      meta_window_actor_update_bounding_region_and_borders (self, pxm_width, pxm_height);
+      meta_window_actor_update_bounding_region_and_borders (self,
+                                                            cogl_texture_get_width (texture),
+                                                            cogl_texture_get_height (texture));
     }
 
   priv->needs_pixmap = FALSE;
@@ -2011,7 +1993,6 @@ meta_window_actor_process_damage (MetaWi
                                   XDamageNotifyEvent *event)
 {
   MetaWindowActorPrivate *priv = self->priv;
-  ClutterX11TexturePixmap *texture_x11 = CLUTTER_X11_TEXTURE_PIXMAP (priv->actor);
 
   priv->received_damage = TRUE;
 
@@ -2039,12 +2020,14 @@ meta_window_actor_process_damage (MetaWi
       return;
     }
 
+  if (!priv->mapped || priv->needs_pixmap)
+    return;
 
-  clutter_x11_texture_pixmap_update_area (texture_x11,
-                                          event->area.x,
-                                          event->area.y,
-                                          event->area.width,
-                                          event->area.height);
+  meta_shaped_texture_update_area (META_SHAPED_TEXTURE (priv->actor),
+                                   event->area.x,
+                                   event->area.y,
+                                   event->area.width,
+                                   event->area.height);
 }
 
 void
diff -urp linuxmint-muffin-0e57527/src/Makefile.am rat4-muffin-80db11c/src/Makefile.am
--- a/src/Makefile.am	2012-03-10 15:13:14.000000000 +0000
+++ b/src/Makefile.am	2012-03-12 02:40:04.000000000 +0000
@@ -54,7 +54,6 @@ libmuffin_la_SOURCES =				\
 	compositor/meta-shadow-factory.c	\
 	compositor/meta-shadow-factory-private.h	\
 	compositor/meta-shaped-texture.c	\
-	compositor/meta-shaped-texture.h	\
 	compositor/meta-texture-rectangle.c	\
 	compositor/meta-texture-rectangle.h	\
 	compositor/meta-texture-tower.c		\
@@ -175,6 +174,7 @@ libmuffininclude_base_headers =		\
 	meta/main.h				\
 	meta/meta-background-actor.h		\
 	meta/meta-plugin.h			\
+	meta/meta-shaped-texture.h		\
 	meta/meta-shadow-factory.h		\
 	meta/meta-window-actor.h		\
 	meta/prefs.h				\
diff -up /dev/null rat4-muffin-80db11c/src/meta/meta-shaped-texture.h 
--- /dev/null	2012-03-12 09:07:57.316000049 +0000
+++ b/src/meta/meta-shaped-texture.h	2012-03-12 02:40:04.000000000 +0000
@@ -0,0 +1,90 @@
+/*
+ * shaped texture
+ *
+ * An actor to draw a texture clipped to a list of rectangles
+ *
+ * Authored By Neil Roberts  <neil@linux.intel.com>
+ *
+ * Copyright (C) 2008 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+
+#ifndef __META_SHAPED_TEXTURE_H__
+#define __META_SHAPED_TEXTURE_H__
+
+#include <clutter/clutter.h>
+#include <X11/Xlib.h>
+
+G_BEGIN_DECLS
+
+#define META_TYPE_SHAPED_TEXTURE            (meta_shaped_texture_get_type())
+#define META_SHAPED_TEXTURE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj),META_TYPE_SHAPED_TEXTURE, MetaShapedTexture))
+#define META_SHAPED_TEXTURE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), META_TYPE_SHAPED_TEXTURE, MetaShapedTextureClass))
+#define META_IS_SHAPED_TEXTURE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), META_TYPE_SHAPED_TEXTURE))
+#define META_IS_SHAPED_TEXTURE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), META_TYPE_SHAPED_TEXTURE))
+#define META_SHAPED_TEXTURE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), META_TYPE_SHAPED_TEXTURE, MetaShapedTextureClass))
+
+typedef struct _MetaShapedTexture        MetaShapedTexture;
+typedef struct _MetaShapedTextureClass   MetaShapedTextureClass;
+typedef struct _MetaShapedTexturePrivate MetaShapedTexturePrivate;
+
+struct _MetaShapedTextureClass
+{
+  ClutterActorClass parent_class;
+};
+
+struct _MetaShapedTexture
+{
+  ClutterActor parent;
+
+  MetaShapedTexturePrivate *priv;
+};
+
+GType meta_shaped_texture_get_type (void) G_GNUC_CONST;
+
+ClutterActor *meta_shaped_texture_new (void);
+
+void meta_shaped_texture_set_create_mipmaps (MetaShapedTexture *stex,
+					     gboolean           create_mipmaps);
+
+void meta_shaped_texture_update_area (MetaShapedTexture *stex,
+                                      int                x,
+                                      int                y,
+                                      int                width,
+                                      int                height);
+
+void meta_shaped_texture_set_pixmap (MetaShapedTexture *stex,
+                                     Pixmap             pixmap);
+
+CoglHandle meta_shaped_texture_get_texture (MetaShapedTexture *stex);
+
+void meta_shaped_texture_set_shape_region (MetaShapedTexture *stex,
+                                           cairo_region_t    *region);
+
+cairo_region_t *meta_shaped_texture_get_visible_pixels_region (MetaShapedTexture *stex);
+
+void meta_shaped_texture_set_overlay_path (MetaShapedTexture *stex,
+                                           cairo_region_t    *overlay_region,
+                                           cairo_path_t      *overlay_path);
+
+/* Assumes ownership of clip_region */
+void meta_shaped_texture_set_clip_region (MetaShapedTexture *stex,
+					  cairo_region_t    *clip_region);
+
+G_END_DECLS
+
+#endif /* __META_SHAPED_TEXTURE_H__ */
diff -urp linuxmint-muffin-0e57527/src/tools/muffin-mag.c rat4-muffin-80db11c/src/tools/muffin-mag.c
--- a/src/tools/muffin-mag.c	2012-03-10 15:13:14.000000000 +0000
+++ b/src/tools/muffin-mag.c	2012-03-12 02:40:04.000000000 +0000
@@ -148,8 +148,15 @@ grab_area_at_mouse (GtkWidget *invisible
 static void
 shutdown_grab (void)
 {
-  gdk_keyboard_ungrab (gtk_get_current_event_time ());
-  gdk_pointer_ungrab (gtk_get_current_event_time ());
+  GdkDeviceManager *manager;
+  GdkDevice *device;
+
+  manager = gdk_display_get_device_manager (gdk_display_get_default ());
+  device = gdk_device_manager_get_client_pointer (manager);
+
+  gdk_device_ungrab (device, gtk_get_current_event_time ());
+  gdk_device_ungrab (gdk_device_get_associated_device (device),
+                     gtk_get_current_event_time ());
   gtk_grab_remove (grab_widget);
 }
 
@@ -227,6 +234,8 @@ static void
 begin_area_grab (void)
 {
   GdkWindow *window;
+  GdkDeviceManager *manager;
+  GdkDevice *device;
 
   if (grab_widget == NULL)
     {
@@ -239,24 +248,31 @@ begin_area_grab (void)
     }
 
   window = gtk_widget_get_window (grab_widget);
+  manager = gdk_display_get_device_manager (gdk_display_get_default ());
+  device = gdk_device_manager_get_client_pointer (manager);
 
-  if (gdk_keyboard_grab (window,
-                         FALSE,
-                         gtk_get_current_event_time ()) != GDK_GRAB_SUCCESS)
+  if (gdk_device_grab (device,
+                       window,
+                       GDK_OWNERSHIP_NONE,
+                       FALSE,
+                       GDK_BUTTON_RELEASE_MASK | GDK_BUTTON_PRESS_MASK | GDK_POINTER_MOTION_MASK,
+                       NULL,
+                       gtk_get_current_event_time ()) != GDK_GRAB_SUCCESS)
     {
-      g_warning ("Failed to grab keyboard to do eyedropper");
+      g_warning ("Failed to grab pointer to do eyedropper");
       return;
     }
-  
-  if (gdk_pointer_grab (window,
-                        FALSE,
-                        GDK_BUTTON_RELEASE_MASK | GDK_BUTTON_PRESS_MASK | GDK_POINTER_MOTION_MASK,
-                        NULL,
-                        NULL,
-                        gtk_get_current_event_time ()) != GDK_GRAB_SUCCESS)
+
+  if (gdk_device_grab (gdk_device_get_associated_device (device),
+                       window,
+                       GDK_OWNERSHIP_NONE,
+                       FALSE,
+                       GDK_KEY_PRESS_MASK | GDK_KEY_RELEASE_MASK,
+                       NULL,
+                       gtk_get_current_event_time ()) != GDK_GRAB_SUCCESS)
     {
-      gdk_keyboard_ungrab (GDK_CURRENT_TIME);
-      g_warning ("Failed to grab pointer to do eyedropper");
+      gdk_device_ungrab (device, gtk_get_current_event_time ());
+      g_warning ("Failed to grab keyboard to do eyedropper");
       return;
     }
 
diff -urp linuxmint-muffin-0e57527/src/tools/muffin-window-demo.c rat4-muffin-80db11c/src/tools/muffin-window-demo.c
--- a/src/tools/muffin-window-demo.c	2012-03-10 15:13:14.000000000 +0000
+++ b/src/tools/muffin-window-demo.c	2012-03-12 02:40:04.000000000 +0000
@@ -353,7 +353,7 @@ utility_cb (GtkAction           *action,
   
   gtk_window_set_transient_for (GTK_WINDOW (window), GTK_WINDOW (callback_data));
   
-  vbox = gtk_vbox_new (FALSE, 0);
+  vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
 
   gtk_container_add (GTK_CONTAINER (window), vbox);
 
@@ -386,7 +386,7 @@ toolbar_cb (GtkAction           *action,
   
   gtk_window_set_transient_for (GTK_WINDOW (window), GTK_WINDOW (callback_data));
   
-  vbox = gtk_vbox_new (FALSE, 0);
+  vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
 
   gtk_container_add (GTK_CONTAINER (window), vbox);
 
@@ -410,7 +410,7 @@ menu_cb (GtkAction           *action,
   
   gtk_window_set_transient_for (GTK_WINDOW (window), GTK_WINDOW (callback_data));
   
-  vbox = gtk_vbox_new (FALSE, 0);
+  vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
 
   gtk_container_add (GTK_CONTAINER (window), vbox);
 
@@ -431,7 +431,7 @@ override_redirect_cb (GtkAction
   window = gtk_window_new (GTK_WINDOW_POPUP);
   gtk_window_set_title (GTK_WINDOW (window), "Override Redirect");
   
-  vbox = gtk_vbox_new (FALSE, 0);
+  vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
 
   gtk_container_add (GTK_CONTAINER (window), vbox);
 
@@ -455,7 +455,7 @@ border_only_cb (GtkAction           *act
   
   gtk_window_set_transient_for (GTK_WINDOW (window), GTK_WINDOW (callback_data));
   
-  vbox = gtk_vbox_new (FALSE, 0);
+  vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
 
   gtk_container_add (GTK_CONTAINER (window), vbox);
 
@@ -477,7 +477,7 @@ changing_icon_cb (GtkAction           *a
   window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
   gtk_window_set_title (GTK_WINDOW (window), "Changing Icon");
   
-  vbox = gtk_vbox_new (FALSE, 0);
+  vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
 
   gtk_container_add (GTK_CONTAINER (window), vbox);
 
@@ -545,7 +545,7 @@ splashscreen_cb (GtkAction           *ac
   set_gtk_window_type (GTK_WINDOW (window), "_NET_WM_WINDOW_TYPE_SPLASHSCREEN");
   gtk_window_set_title (GTK_WINDOW (window), "Splashscreen");
   
-  vbox = gtk_vbox_new (FALSE, 0);
+  vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
   
   image = gtk_image_new_from_stock (GTK_STOCK_DIALOG_INFO, GTK_ICON_SIZE_DIALOG);
   gtk_box_pack_start (GTK_BOX (vbox), image, FALSE, FALSE, 0);
@@ -581,11 +581,11 @@ make_dock (int type)
     {
     case DOCK_LEFT:
     case DOCK_RIGHT:      
-      box = gtk_vbox_new (FALSE, 0);
+      box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
       break;
     case DOCK_TOP:
     case DOCK_BOTTOM:
-      box = gtk_hbox_new (FALSE, 0);
+      box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
       break;
     case DOCK_ALL:
       break;
@@ -909,8 +909,7 @@ static GtkWidget *
 do_appwindow (void)
 {
   GtkWidget *window;
-  GtkWidget *table;
-  GtkWidget *handlebox;
+  GtkWidget *grid;
   GtkWidget *statusbar;
   GtkWidget *contents;
   GtkWidget *sw;
@@ -931,9 +930,12 @@ do_appwindow (void)
   g_signal_connect (G_OBJECT (window), "destroy",
                     G_CALLBACK (destroy_cb), NULL);
       
-  table = gtk_table_new (1, 4, FALSE);
-      
-  gtk_container_add (GTK_CONTAINER (window), table);
+  grid = gtk_grid_new ();
+
+  gtk_widget_set_vexpand (grid, TRUE);
+  gtk_widget_set_hexpand (grid, TRUE);
+
+  gtk_container_add (GTK_CONTAINER (window), grid);
       
   /* Create the menubar
    */
@@ -958,12 +960,12 @@ do_appwindow (void)
 
   gtk_ui_manager_add_ui_from_string (ui_manager, menu_item_string, -1, NULL);
 
-  gtk_table_attach (GTK_TABLE (table),
-                    gtk_ui_manager_get_widget (ui_manager, "/ui/menubar"),
-                    /* X direction */          /* Y direction */
-                    0, 1,                      0, 1,
-                    GTK_EXPAND | GTK_FILL,     0,
-                    0,                         0);
+  gtk_grid_attach (GTK_GRID (grid),
+                   gtk_ui_manager_get_widget (ui_manager, "/ui/menubar"),
+                   0, 0, 1, 1);
+
+  gtk_widget_set_hexpand (gtk_ui_manager_get_widget (ui_manager, "/ui/menubar"),
+                          TRUE);
 
   /* Create document
    */
@@ -976,13 +978,13 @@ do_appwindow (void)
 
   gtk_scrolled_window_set_shadow_type (GTK_SCROLLED_WINDOW (sw),
                                        GTK_SHADOW_IN);
-      
-  gtk_table_attach (GTK_TABLE (table),
-                    sw,
-                    /* X direction */       /* Y direction */
-                    0, 1,                   2, 3,
-                    GTK_EXPAND | GTK_FILL,  GTK_EXPAND | GTK_FILL,
-                    0,                      0);
+
+  gtk_grid_attach (GTK_GRID (grid),
+                   sw,
+                   0, 2, 1, 1);
+
+  gtk_widget_set_hexpand (sw, TRUE);
+  gtk_widget_set_vexpand (sw, TRUE);
 
   gtk_window_set_default_size (GTK_WINDOW (window),
                                200, 200);
@@ -996,27 +998,22 @@ do_appwindow (void)
   /* Create the toolbar
    */
 
-  handlebox = gtk_handle_box_new ();
+  gtk_grid_attach (GTK_GRID (grid),
+                   gtk_ui_manager_get_widget (ui_manager, "/ui/toolbar"),
+                   0, 1, 1, 1);
 
-  gtk_container_add (GTK_CONTAINER (handlebox),
-                     gtk_ui_manager_get_widget (ui_manager, "/ui/toolbar"));
-      
-  gtk_table_attach (GTK_TABLE (table),
-                    handlebox,
-                    /* X direction */       /* Y direction */
-                    0, 1,                   1, 2,
-                    GTK_EXPAND | GTK_FILL,  0,
-                    0,                      0);
+  gtk_widget_set_hexpand (gtk_ui_manager_get_widget (ui_manager, "/ui/toolbar"),
+                          TRUE);
 
   /* Create statusbar */
 
   statusbar = gtk_statusbar_new ();
-  gtk_table_attach (GTK_TABLE (table),
-                    statusbar,
-                    /* X direction */       /* Y direction */
-                    0, 1,                   3, 4,
-                    GTK_EXPAND | GTK_FILL,  0,
-                    0,                      0);
+  gtk_grid_attach (GTK_GRID (grid),
+                   statusbar,
+                   0, 3, 1, 1);
+
+  gtk_widget_set_hexpand (statusbar,
+                          TRUE);
 
   /* Show text widget info in the statusbar */
   buffer = gtk_text_view_get_buffer (GTK_TEXT_VIEW (contents));
diff -urp linuxmint-muffin-0e57527/src/ui/frames.c rat4-muffin-80db11c/src/ui/frames.c
--- a/src/ui/frames.c	2012-03-10 15:13:14.000000000 +0000
+++ b/src/ui/frames.c	2012-03-12 02:40:04.000000000 +0000
@@ -1942,7 +1942,7 @@ meta_frames_motion_notify_event     (Gtk
   Display *display;
   
   frames = META_FRAMES (widget);
-  display = GDK_DISPLAY_XDISPLAY (gdk_display_get_default ());
+  display = GDK_DISPLAY_XDISPLAY (gdk_window_get_display (event->window));
   
   frame = meta_frames_lookup_window (frames, GDK_WINDOW_XID (event->window));
   if (frame == NULL)
@@ -1971,7 +1971,8 @@ meta_frames_motion_notify_event     (Gtk
         MetaFrameControl control;
         int x, y;
         
-        gdk_window_get_pointer (frame->window, &x, &y, NULL);
+        gdk_window_get_device_position (frame->window, event->device,
+                                        &x, &y, NULL);
 
         /* Control is set to none unless it matches
          * the current grab
@@ -2012,7 +2013,8 @@ meta_frames_motion_notify_event     (Gtk
         MetaFrameControl control;
         int x, y;
         
-        gdk_window_get_pointer (frame->window, &x, &y, NULL);
+        gdk_window_get_device_position (frame->window, event->device,
+                                        &x, &y, NULL);
 
         control = get_control (frames, frame, x, y);
 
diff -urp linuxmint-muffin-0e57527/src/ui/menu.c rat4-muffin-80db11c/src/ui/menu.c
--- a/src/ui/menu.c	2012-03-10 15:13:14.000000000 +0000
+++ b/src/ui/menu.c	2012-03-12 02:40:04.000000000 +0000
@@ -116,7 +116,7 @@ popup_position_func (GtkMenu   *menu,
 
   pos = user_data;
   
-  gtk_widget_size_request (GTK_WIDGET (menu), &req);
+  gtk_widget_get_preferred_size (GTK_WIDGET (menu), &req, NULL);
 
   *x = pos->x;
   *y = pos->y;
diff -urp linuxmint-muffin-0e57527/src/ui/tabpopup.c rat4-muffin-80db11c/src/ui/tabpopup.c
--- a/src/ui/tabpopup.c	2012-03-10 15:13:14.000000000 +0000
+++ b/src/ui/tabpopup.c	2012-03-12 02:40:04.000000000 +0000
@@ -217,9 +217,9 @@ meta_ui_tab_popup_new (const MetaTabEntr
                        gboolean            outline)
 {
   MetaTabPopup *popup;
-  int i, left, right, top, bottom;
+  int i, left, top;
   int height;
-  GtkWidget *table;
+  GtkWidget *grid;
   GtkWidget *vbox;
   GtkWidget *align;
   GList *tmp;
@@ -273,12 +273,12 @@ meta_ui_tab_popup_new (const MetaTabEntr
   if (i % width)
     height += 1;
 
-  table = gtk_table_new (height, width, FALSE);
-  vbox = gtk_vbox_new (FALSE, 0);
+  grid = gtk_grid_new ();
+  vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
   
   frame = gtk_frame_new (NULL);
   gtk_frame_set_shadow_type (GTK_FRAME (frame), GTK_SHADOW_OUT);
-  gtk_container_set_border_width (GTK_CONTAINER (table), 1);
+  gtk_container_set_border_width (GTK_CONTAINER (grid), 1);
   gtk_container_add (GTK_CONTAINER (popup->window),
                      frame);
   gtk_container_add (GTK_CONTAINER (frame),
@@ -289,7 +289,7 @@ meta_ui_tab_popup_new (const MetaTabEntr
   gtk_box_pack_start (GTK_BOX (vbox), align, TRUE, TRUE, 0);
 
   gtk_container_add (GTK_CONTAINER (align),
-                     table);
+                     grid);
 
   popup->label = gtk_label_new ("");
 
@@ -306,13 +306,11 @@ meta_ui_tab_popup_new (const MetaTabEntr
 
   max_label_width = 0;
   top = 0;
-  bottom = 1;
   tmp = popup->entries;
 
   while (tmp && top < height)
     {      
       left = 0;
-      right = 1;
 
       while (tmp && left < width)
         {
@@ -351,26 +349,22 @@ meta_ui_tab_popup_new (const MetaTabEntr
 
           te->widget = image;
 
-          gtk_table_attach (GTK_TABLE (table),
-                            te->widget,
-                            left, right,           top, bottom,
-                            0,                     0,
-                            0,                     0);
+          gtk_grid_attach (GTK_GRID (grid),
+                           te->widget,
+                           left, top, 1, 1);
 
           /* Efficiency rules! */
           gtk_label_set_markup (GTK_LABEL (popup->label),
                               te->title);
-          gtk_widget_size_request (popup->label, &req);
+          gtk_widget_get_preferred_size (popup->label, &req, NULL);
           max_label_width = MAX (max_label_width, req.width);
           
           tmp = tmp->next;
           
           ++left;
-          ++right;
         }
       
       ++top;
-      ++bottom;
     }
 
   /* remove all the temporary text */
diff -urp linuxmint-muffin-0e57527/src/ui/theme.c rat4-muffin-80db11c/src/ui/theme.c
--- a/src/ui/theme.c	2012-03-10 15:13:14.000000000 +0000
+++ b/src/ui/theme.c	2012-03-12 02:40:04.000000000 +0000
@@ -6403,6 +6403,8 @@ meta_gtk_state_from_string (const char *
     return GTK_STATE_FLAG_INCONSISTENT;
   else if (g_ascii_strcasecmp ("focused", str) == 0)
     return GTK_STATE_FLAG_FOCUSED;
+  else if (g_ascii_strcasecmp ("backdrop", str) == 0)
+    return GTK_STATE_FLAG_BACKDROP;
   else
     return -1; /* hack */
 }
@@ -6426,6 +6428,8 @@ meta_gtk_state_to_string (GtkStateFlags
       return "INCONSISTENT";
     case GTK_STATE_FLAG_FOCUSED:
       return "FOCUSED";
+    case GTK_STATE_FLAG_BACKDROP:
+      return "BACKDROP";
     }
 
   return "<unknown>";
diff -urp linuxmint-muffin-0e57527/src/ui/theme-viewer.c rat4-muffin-80db11c/src/ui/theme-viewer.c
--- a/src/ui/theme-viewer.c	2012-03-10 15:13:14.000000000 +0000
+++ b/src/ui/theme-viewer.c	2012-03-12 02:40:04.000000000 +0000
@@ -122,19 +122,18 @@ static GtkActionEntry tool_items[] =
 static GtkWidget *
 normal_contents (void)
 {
-  GtkWidget *table;
-  GtkWidget *handlebox;
+  GtkWidget *grid;
   GtkWidget *statusbar;
   GtkWidget *contents;
   GtkWidget *sw;
   GtkActionGroup *action_group;
   GtkUIManager *ui_manager;
       
-  table = gtk_table_new (1, 4, FALSE);
-  
+  grid = gtk_grid_new ();
+
   /* Create the menubar
    */
-      
+
   action_group = gtk_action_group_new ("mainmenu");
   gtk_action_group_add_actions (action_group,
                                 menu_items,
@@ -152,24 +151,15 @@ normal_contents (void)
   /* create menu items */
   gtk_ui_manager_add_ui_from_string (ui_manager, menu_item_string, -1, NULL);
 
-  gtk_table_attach (GTK_TABLE (table),
-                    gtk_ui_manager_get_widget (ui_manager, "/ui/menubar"),
-                    /* X direction */          /* Y direction */
-                    0, 1,                      0, 1,
-                    GTK_EXPAND | GTK_FILL,     0,
-                    0,                         0);
-
-  handlebox = gtk_handle_box_new ();
-
-  gtk_container_add (GTK_CONTAINER (handlebox),
-                     gtk_ui_manager_get_widget (ui_manager, "/ui/toolbar"));
-
-  gtk_table_attach (GTK_TABLE (table),
-                    handlebox,
-                    /* X direction */       /* Y direction */
-                    0, 1,                   1, 2,
-                    GTK_EXPAND | GTK_FILL,  0,
-                    0,                      0);
+  gtk_grid_attach (GTK_GRID (grid),
+                   gtk_ui_manager_get_widget (ui_manager, "/ui/menubar"),
+                   0, 0, 1, 1);
+
+  /* Create the toolbar
+   */
+  gtk_grid_attach (GTK_GRID (grid),
+                   gtk_ui_manager_get_widget (ui_manager, "/ui/toolbar"),
+                   0, 1, 1, 1);
 
   /* Create document
    */
@@ -183,12 +173,9 @@ normal_contents (void)
   gtk_scrolled_window_set_shadow_type (GTK_SCROLLED_WINDOW (sw),
                                        GTK_SHADOW_IN);
       
-  gtk_table_attach (GTK_TABLE (table),
-                    sw,
-                    /* X direction */       /* Y direction */
-                    0, 1,                   2, 3,
-                    GTK_EXPAND | GTK_FILL,  GTK_EXPAND | GTK_FILL,
-                    0,                      0);
+  gtk_grid_attach (GTK_GRID (grid),
+                   sw,
+                   0, 2, 1, 1);
       
   contents = gtk_text_view_new ();
   gtk_text_view_set_wrap_mode (GTK_TEXT_VIEW (contents),
@@ -200,18 +187,15 @@ normal_contents (void)
   /* Create statusbar */
 
   statusbar = gtk_statusbar_new ();
-  gtk_table_attach (GTK_TABLE (table),
-                    statusbar,
-                    /* X direction */       /* Y direction */
-                    0, 1,                   3, 4,
-                    GTK_EXPAND | GTK_FILL,  0,
-                    0,                      0);
+  gtk_grid_attach (GTK_GRID (grid),
+                   statusbar,
+                   0, 3, 1, 1);
 
-  gtk_widget_show_all (table);
+  gtk_widget_show_all (grid);
 
   g_object_unref (ui_manager);
 
-  return table;
+  return grid;
 }
 
 static void
@@ -233,7 +217,7 @@ dialog_contents (void)
   GtkWidget *image;
   GtkWidget *button;
   
-  vbox = gtk_vbox_new (FALSE, 0);
+  vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
 
   action_area = gtk_button_box_new (GTK_ORIENTATION_HORIZONTAL);
 
@@ -258,7 +242,7 @@ dialog_contents (void)
   gtk_label_set_line_wrap (GTK_LABEL (label), TRUE);
   gtk_label_set_selectable (GTK_LABEL (label), TRUE);
   
-  hbox = gtk_hbox_new (FALSE, 6);
+  hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 6);
 
   gtk_box_pack_start (GTK_BOX (hbox), image,
                       FALSE, FALSE, 0);
@@ -278,11 +262,11 @@ dialog_contents (void)
 static GtkWidget*
 utility_contents (void)
 {
-  GtkWidget *table;
+  GtkWidget *grid;
   GtkWidget *button;
   int i, j;
 
-  table = gtk_table_new (3, 4, FALSE);
+  grid = gtk_grid_new ();
 
   i = 0;
   while (i < 3)
@@ -298,12 +282,9 @@ utility_contents (void)
 
           g_free (str);
           
-          gtk_table_attach (GTK_TABLE (table),
-                            button,
-                            /* X direction */       /* Y direction */
-                            i, i+1,                   j, j+1,
-                            GTK_EXPAND | GTK_FILL,  GTK_EXPAND | GTK_FILL,
-                            0,                      0);
+          gtk_grid_attach (GTK_GRID (grid),
+                           button,
+                           i, j, 1, 1);
 
           ++j;
         }
@@ -311,9 +292,9 @@ utility_contents (void)
       ++i;
     }
 
-  gtk_widget_show_all (table);
+  gtk_widget_show_all (grid);
   
-  return table;
+  return grid;
 }
 
 static GtkWidget*
@@ -328,7 +309,7 @@ menu_contents (void)
   gtk_frame_set_shadow_type (GTK_FRAME (frame),
                              GTK_SHADOW_OUT);
 
-  vbox = gtk_vbox_new (FALSE, 0);
+  vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
 
   i = 0;
   while (i < 10)
@@ -365,7 +346,7 @@ border_only_contents (void)
   color.alpha = 1.0;
   gtk_widget_override_background_color (event_box, 0, &color);
   
-  vbox = gtk_vbox_new (FALSE, 0);
+  vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
   gtk_container_set_border_width (GTK_CONTAINER (vbox), 3);
   
   w = gtk_label_new (_("Border-only window"));
@@ -487,7 +468,7 @@ preview_collection (int font_size,
                                   GTK_POLICY_AUTOMATIC,
                                   GTK_POLICY_AUTOMATIC);
 
-  box = gtk_vbox_new (FALSE, 0);
+  box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
   gtk_box_set_spacing (GTK_BOX (box), 20);
   gtk_container_set_border_width (GTK_CONTAINER (box), 20);
 
@@ -711,7 +692,7 @@ previews_of_button_layouts (void)
                                   GTK_POLICY_AUTOMATIC,
                                   GTK_POLICY_AUTOMATIC);
 
-  box = gtk_vbox_new (FALSE, 0);
+  box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
   gtk_box_set_spacing (GTK_BOX (box), 20);
   gtk_container_set_border_width (GTK_CONTAINER (box), 20);
 
diff -urp linuxmint-muffin-0e57527/src/ui/ui.c rat4-muffin-80db11c/src/ui/ui.c
--- a/src/ui/ui.c	2012-03-10 15:13:14.000000000 +0000
+++ b/src/ui/ui.c	2012-03-12 02:40:04.000000000 +0000
@@ -102,6 +102,7 @@ maybe_redirect_mouse_event (XEvent *xeve
 {
   GdkDisplay *gdisplay;
   GdkDeviceManager *gmanager;
+  GdkDevice *gdevice;
   MetaUI *ui;
   GdkEvent *gevent;
   GdkWindow *gdk_window;
@@ -133,11 +134,14 @@ maybe_redirect_mouse_event (XEvent *xeve
   if (gdk_window == NULL)
     return FALSE;
 
+  gmanager = gdk_display_get_device_manager (gdisplay);
+  gdevice = gdk_device_manager_get_client_pointer (gmanager);
+
   /* If GDK already thinks it has a grab, we better let it see events; this
    * is the menu-navigation case and events need to get sent to the appropriate
    * (client-side) subwindow for individual menu items.
    */
-  if (gdk_display_pointer_is_grabbed (gdisplay))
+  if (gdk_display_device_is_grabbed (gdisplay, gdevice))
     return FALSE;
 
   switch (xevent->type)
@@ -207,8 +211,7 @@ maybe_redirect_mouse_event (XEvent *xeve
     }
 
   /* If we've gotten here, we've created the gdk_event and should send it on */
-  gmanager = gdk_display_get_device_manager (gdisplay);
-  gdk_event_set_device (gevent, gdk_device_manager_get_client_pointer (gmanager));
+  gdk_event_set_device (gevent, gdevice);
   gtk_main_do_event (gevent);
   gdk_event_free (gevent);
 
